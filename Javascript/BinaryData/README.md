# Binary data

## Array buffer 
Binary data in JavaScript is implemented in a non-standard way, compared to other languages. But when we sort things out, everything becomes fairly simple.

The basic binary object is `ArrayBuffer` – a reference to a fixed-length contiguous memory area.

```
let buffer = new ArrayBuffer(16); // create a buffer of length 16
```

`ArrayBuffer` is a memory area. Just a raw sequence of bytes.

To manipulate an `ArrayBuffer`, we need to use a “view” object.

A view object does not store anything on its own. It’s the “eyeglasses” that give an interpretation of the bytes stored in the ArrayBuffer.


- `Uint8Array` – treats each byte in ArrayBuffer as a separate number, with possible values from 0 to 255 (a byte is 8-bit, so it can hold only that much). Such value is called a “8-bit unsigned integer”.
- `Uint16Array` – treats every 2 bytes as an integer, with possible values from 0 to 65535. That’s called a “16-bit unsigned integer”.
- `Uint32Array` – treats every 4 bytes as an integer, with possible values from 0 to 4294967295. That’s called a “32-bit unsigned integer”.
- `Float64Array` – treats every 8 bytes as a floating point number with possible values from 5.0x10-324 to 1.8x10308.

So, the binary data in an ArrayBuffer of 16 bytes can be interpreted as 16 “tiny numbers”, or 8 bigger numbers (2 bytes each), or 4 even bigger (4 bytes each), or 2 floating-point values with high precision (8 bytes each).

> **TypedArray** - the common term for all these views (Uint8Array, Uint32Array, etc) is TypedArray. They share the same set of methods and properties. There’s no constructor called TypedArray, it’s just a common “umbrella” term to represent one of views over ArrayBuffer: Int8Array, Uint8Array and so on.

### DataView
`DataView` is a special super-flexible “untyped” view over ArrayBuffer. It allows to access the data on any offset in any format.
```
// binary array of 4 bytes, all have the maximal value 255
let buffer = new Uint8Array([255, 255, 255, 255]).buffer;

let dataView = new DataView(buffer);

// get 8-bit number at offset 0
alert( dataView.getUint8(0) ); // 255

// now get 16-bit number at offset 0, it consists of 2 bytes, together interpreted as 65535
alert( dataView.getUint16(0) ); // 65535 (biggest 16-bit unsigned int)

// get 32-bit number at offset 0
alert( dataView.getUint32(0) ); // 4294967295 (biggest 32-bit unsigned int)

dataView.setUint32(0, 0); // set 4-byte number to zero, thus setting all bytes to 0
```

### Summary
![image](https://github.com/user-attachments/assets/e0877742-7c63-4cc2-aec2-41fc7b26a967)

## TextDecoder and TextEncoder
The built-in TextDecoder object allows one to read the value into an actual JavaScript string, given the buffer and the encoding.

Read from buffer
```
let uint8Array = new Uint8Array([72, 101, 108, 108, 111]);

alert( new TextDecoder().decode(uint8Array) ); // Hello
```

Write as a buffer
```
let encoder = new TextEncoder();

let uint8Array = encoder.encode("Hello");
alert(uint8Array); // 72,101,108,108,111
```

## Blob
`Blob` is a  higher-level objects, described in File API in a browser which represents immutable raw binary data. Blobs are particularly useful for handling file uploads/downloads, creating object URLs, and manipulating binary data in web applications.

A Blob is created using the Blob() constructor, which accepts an array of data parts and an optional options object:
```
let blob = new Blob(["<html>…</html>"], { type: 'text/html' });

---
let hello = new Uint8Array([72, 101, 108, 108, 111]); // "Hello"
let blob = new Blob([hello, ' ', 'world'], { type: 'text/plain' });
```

Blobs are immutable, but you can create new Blob objects by slicing existing ones using the slice() method:​
```
let newBlob = blob.slice(startByte, endByte, contentType);
```

### Using Blob as a URL
Blobs can be converted into object URLs using URL.createObjectURL(), allowing them to be used as sources for <a>, <img>, or other tags:
```
let link = document.createElement('a');
link.download = 'hello.txt';

let blob = new Blob(['Hello, world!'], {type: 'text/plain'});

link.href = URL.createObjectURL(blob);

link.click();

URL.revokeObjectURL(link.href);
```

For each URL generated by URL.createObjectURL the browser stores a URL → Blob mapping internally. So such URLs are short, but allow to access the Blob. So if we create a URL, that Blob will hang in memory, even if not needed any more.
`URL.revokeObjectURL(url)` removes the reference from the internal mapping, thus allowing the Blob to be deleted (if there are no other references), and the memory to be freed.

#### Blob to base64
An alternative to URL.createObjectURL is to convert a Blob into a base64-encoded string.
```
let link = document.createElement('a');
link.download = 'hello.txt';

let blob = new Blob(['Hello, world!'], {type: 'text/plain'});

let reader = new FileReader();
reader.readAsDataURL(blob); // converts the blob to base64 and calls onload

reader.onload = function() {
  link.href = reader.result; // data url
  link.click();
};
```

### From Blob to stream
A stream is a special object that allows to read from it (or write into it) portion by portion. It’s outside of our scope here, but here’s an example, and you can read more at https://developer.mozilla.org/en-US/docs/Web/API/Streams_API. Streams are convenient for data that is suitable for processing piece-by-piece.

```
// get readableStream from blob
const readableStream = blob.stream();
const stream = readableStream.getReader();

while (true) {
  // for each iteration: value is the next blob fragment
  let { done, value } = await stream.read();
  if (done) {
    // no more data in the stream
    console.log('all blob processed.');
    break;
  }

   // do something with the data portion we've just read from the blob
  console.log(value);
}
```

## File and FileReader
A `File` object inherits from Blob and is extended with filesystem-related capabilities.

Usualy we get a file from `<input type="file">` or drag’n’drop or other browser interfaces. In that case, the file gets this information from OS.

```
<input type="file" onchange="showFile(this)">

<script>
function showFile(input) {
  let file = input.files[0];

  alert(`File name: ${file.name}`); // e.g my.png
  alert(`Last modified: ${file.lastModified}`); // e.g 1552830408824
}
</script>
```

### FileREader
FileReader is an object with the sole purpose of reading data from Blob (and hence File too) objects.

```
<input type="file" onchange="readFile(this)">

<script>
function readFile(input) {
  let file = input.files[0];

  let reader = new FileReader();

  reader.readAsText(file);

  reader.onload = function() {
    console.log(reader.result);
  };

  reader.onerror = function() {
    console.log(reader.error);
  };

}
</script>
```